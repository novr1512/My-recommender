# -*- coding: utf-8 -*-
"""engine.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m3-3Eu311C-Cff_6noxzN7PfoEcBsu0b

# Movies dataset

This project aims to recommend movies to users based on other users' ratings and tag similarity 

## About the dataset
This dataset (ml-25m) describes 5-star rating from MovieLens. It contains 25000095 ratings and 1093360 tag applications across 62423 movies. These data were created by 162541 users between January 09, 1995 and November 21, 2019. This dataset was generated on November 21, 2019.

it contains 4 files, which are :
- movies 
- ratings
- genome-tags
- genome-scores

---
#### Step 1 : set up
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# # data management
# ! pip install -U pandas
# ! pip install -U numpy
# 
# # data visualization
# ! pip install -U matplotlib
# ! pip install -U plotnine
# 
# # modeling
# ! pip install -U scikit-learn
# 
#

! pip uninstall matplotlib
! pip install matplotlib==3.1.3

! pip install mxnet
#! pip install graphviz
! pip install -U d2l
! pip install implicit
! pip install recmetrics
! pip install ml_metrics

"""import libraries"""

import os
from mxnet import gluon, np
import pandas as pd
from d2l import mxnet as d2l
import sys
import numpy as np
import scipy.sparse as sparse
from scipy.sparse.linalg import spsolve
import random
import implicit 
from sklearn.model_selection import train_test_split, KFold, RepeatedKFold, cross_val_score
import recmetrics
from pandas.core.dtypes.inference import is_dict_like
import matplotlib.pyplot as plt
import ml_metrics as metrics
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.model_selection import cross_val_score
from skopt import gp_minimize

"""import data from google drive"""

from google.colab import drive
drive.mount('/content/drive')

"""---
#### Step 2 : upload files

movies file contain info about 62423 movies,
- movieId : unique identifer across files
- title : movie title
- genres : pipe-separated list of movie genres
"""

movies=pd.read_csv('/content/drive/MyDrive/data/movies.csv')

movies.head()

"""ratings file contain info about 25000095 ratings,
- movieId : movie unique identifer across files
- userId : user unique identifer across files
- rating : user rating out of 5 stars
"""

ratings =pd.read_csv('/content/drive/MyDrive/data/ratings.csv')

ratings.head()

ratings.drop('timestamp',axis = 1 , inplace = True)

"""tags are distrbuted in 2 files:
- genome-tags : which includes the tags id and the tag name
- genome-scores : which includes the tage id, the movie id and the relevance between them (at scale from 0 to 1)

"""

scores =pd.read_csv('/content/drive/MyDrive/data/genome-scores.csv')

scores.head()

tags =pd.read_csv('/content/drive/MyDrive/data/genome-tags.csv')

tags.sample(10)

"""---
#### Step 3 : exploring
"""

d2l.plt.hist(ratings['rating'], bins=5, ec='black')
d2l.plt.xlabel('Rating')
d2l.plt.ylabel('Count')
d2l.plt.title('Distribution of Ratings in MovieLens ')
d2l.plt.show()

"""some movies have a lot of ratings and some have only 1, 75% of them have 36 ratings or less"""

counts = ratings['movieId'].value_counts()
counts.describe()

fig = plt.figure(figsize=(15, 7))
recmetrics.long_tail_plot(df=ratings, 
             item_id_column="movieId", 
             interaction_type="movie ratings", 
             x_labels=False)

"""---
#### Step 4 : model building

the project requirments :
- the system can show search suggestion if there's more than one movie with the same name
- the system will show the user the suggested movies based on the one they like, the recommendation will be based on other users preferances and the tag relevance between the movie and other movies
 
it is hybird recommendation system that uses collaborative-based and content-based algorithms
"""

#input movie
movieName= 'Toy Story'
movieRow = movies[movies['title'].str.contains(movieName)]
movieRow

movieID = 1

#look for the highest related tag
AllMovieScores = scores[scores['movieId']==movieID]
AllMovieScores.sort_values(by=['relevance'],ascending=False, inplace=True)
AllMovieScores.head()

# who also likes the movie ?
UsersWhoWatched = ratings[ratings['movieId']==movieID]
UsersWhoWatched

"""# Model- based collabrative filtering
# ALS - Alternating Least Square

splitting the data
"""

y = ratings["userId"]
train_strat, test_strat = train_test_split(ratings, train_size=0.60, random_state=123)

"""convert into matrises as ALS model input"""

#smaller train matrices 
sparse_movie_user = sparse.csr_matrix((train_strat['rating'].astype(float), (train_strat['movieId'], train_strat['userId'])))
sparse_user_movie = sparse.csr_matrix((train_strat['rating'].astype(float), (train_strat['userId'], train_strat['movieId'])))

#os.environ['MKL_NUM_THREADS'] = '1'

#Building the model
model = implicit.gpu.als.AlternatingLeastSquares(regularization=0.03, iterations=40)
alpha_val = 2
data_conf = (sparse_user_movie * alpha_val).astype('double')
model.fit(data_conf)

#Get Recommendations
# returns 2 variables: ids, scores
user_id =[1,100,200,500]
def ALSrecommendations(user_id):
  return model.recommend(user_id, sparse_user_movie[user_id],N=10)

"""function to retrive the movies names from list of ids :"""

def findMoviesName(idList):
    listofmovies = pd.DataFrame()
    idList = idList.tolist()
    for id in idList:
        listofmovies = listofmovies.append(movies[movies['movieId']==id], ignore_index = False)

    return listofmovies

"""fuction to join movies and ratings dataframes :"""

def joinRatingswithMovies(ratingList):
    return pd.merge(ratingList,movies,on='movieId')

"""function to get the movies that atr in ratings"""

def ratingsToMovies(ratingsList):
    movieslist = pd.DataFrame()
    for index, row in ratingsList.iterrows():
        movieslist = movieslist.append(movies[movies['movieId'] == row['movieId']], ignore_index = True)
    return movieslist

"""# Memory-based content filtering

function used to minimize the tags and remove redundent :
"""

def deleteTags(ListoftagsIds,scores):
    TagOnly = scores
    #find each movie
    for id in ListoftagsIds:
        TagOnly=TagOnly[TagOnly['tagId']!=id]
    return TagOnly

"""deleting tags for the memory- based model"""

# 9,1980s + 13,80s 
#15,aardman + 16,aardman studios
#22,adapted from:book + 107,based on a book + 113,based on book + 152,book + 153,book was better
#23,adapted from:comic + 108,based on a comic + 114,based on comic + 231,comic + 232,comic book + 233,comic book adaption + 234,comics + 290,dc comics
TagOnly = deleteTags([13,16,107,113,152,153,108,114,231,232,233,234,290],scores)
#24,adapted from:game + 112,based on a video game + 245,computer game + 1074,video game + 1075,video game adaptation + 1076,video games + 1077,videogame
#43,alien + 44,alien invasion + 45,aliens
#59,android(s)/cyborg(s) + 60,androids
#886,sci fi + 887,sci-fi + 888,science + 889,science fiction + 890,scifi + 891,scifi cult
TagOnly = deleteTags([112,245,1074,1075,1076,1077,44,45,60,887,888,889,890,891],TagOnly)

#61,animal movie + 62,animals + 316,dog + 317,dogs + 318,dolphins + 783,pigs

#63,animated + 64,animation + 65,anime + 244,computer animation + 310,disney animated feature

#75,art + 78,artist + 79,artistic

#81,assassin + 82,assassination + 83,assassins

#87,australia + 88,australian

#115,based on true story + 110,based on a true story + 1047,true story

#1013,teen + 1014,teen movie + 1015,teenager + 1016,teenagers + 1017,teens

#127,best war films + 1096,war + 1097,war movie + 1098,wartime

#133,biographical + 134,biography

#141,black comedy + 286,dark comedy + 289,dark humor

#145,blood + 146,bloody

#798,political + 799,political corruption + 800,politics + 1119,world politics

#155,boring + 156,boring!

#176,camp + 177,campy

#208,christian + 209,christianity

#220,clever + 992,suprisingly clever + 550,intellectual + 551,intelligent + 552,intelligent sci-fi + 430,genius

#221,clones + 222,cloning

#235,coming of age + 236,coming-of-age

#240,complex + 242,complicated

#261,court + 262,courtroom + 263,courtroom drama

#278,cute + 279,cute!

# 283,dance + 284,dancing

#296,depressing + 297,depression

#323,drama + 324,dramatic + 376,family drama

#357,environment + 358,environmental

#371,fairy tale + 372,fairy tales

#384,father son relationship + 385,father-son relationship

#377,fantasy + 378,fantasy world

#387,feel good movie + 388,feel-good

#435,ghosts + 436,ghosts/afterlife + 35,afterlife
#389,fight scenes + 390,fighting

#684,music + 685,music business + 686,musical + 687,musicians

#329,drug abuse + 330,drug addiction + 331,drugs + 499,heroin + 500,heroine + 501,heroine in tight suit

#548,inspirational + 549,inspiring

#696,nazi + 697,nazis + 698,neil gaiman + 699,neo-nazis

#905,sex + 907,sexual + 909,sexuality + 911,sexy

#908,sexual abuse + 910,sexualized violence

#789,plot twist + 1049,twist + 1050,twist ending + 1051,twists & turns

#987,super hero + 988,super-hero + 989,superhero + 990,superheroes + 991,supernatural

#725,nudity + 726,nudity (full frontal - brief) + 727,nudity (full frontal - notable) + 728,nudity (full frontal) + 729,nudity (rear) + 730,nudity (topless - brief) + 731,nudity (topless - notable) + 732,nudity (topless)

#414,fun + 415,fun movie + 416,funniest movies + 417,funny + 418,funny as hell + 1071,very funny + 1058,unintentionally funny + 933,so bad it's funny + 920,silly fun + 333,dumb but funny

"""merge tags, scores and movies in one dataFrame"""

MovieTagsUnion = scores.merge(tags, on = 'tagId').merge(movies, on = 'movieId')

""" rank based on tags"""

MovieTagsUnion['relevance_rank'] = MovieTagsUnion.groupby("movieId")["relevance"].rank(method = "first", ascending = False).astype('int64')

"""get a list of top 100 tags for each movie"""

mv_tags_list = MovieTagsUnion[MovieTagsUnion.relevance_rank <= 100].groupby(['movieId','title'])['tag'].apply(lambda x: ','.join(x)).reset_index()
mv_tags_list['tag_list'] = mv_tags_list.tag.map(lambda x: x.split(','))

"""function to find movies similar to one movie"""

def findsimilarMovie(target_movie):
  # compute Jaccard Index to get most similar movies to target movie
  target_movieName=  mv_tags_list[mv_tags_list['movieId'] == target_movie]
  similarList = pd.DataFrame()
  if (len(target_movieName) != 0 ):
    target_movieName = target_movieName['title'].values[0]
    pd.reset_option('display.max_colwidth')
    target_tag_list = mv_tags_list[mv_tags_list['movieId'] == target_movie].tag_list.values[0]
    mv_tags_list_sim = mv_tags_list[['movieId','title','tag_list','tag']]
    mv_tags_list_sim['jaccard_sim'] = mv_tags_list_sim.tag_list.map(lambda x: len(set(x).intersection(set(target_tag_list))) / len(set(x).union(set(target_tag_list))))
    print(f'Movies most similar to {target_movieName} based on tags:')
    text = ','.join(mv_tags_list_sim.sort_values(by = 'jaccard_sim', ascending = False).head(25)['tag'].values)
    similarList = mv_tags_list_sim.sort_values(by = 'jaccard_sim', ascending = False).iloc[1:11]

  return similarList

"""find similar movies based on user likes """

def findJaccardRecommendations(SingleuserId):
  original =train_strat[train_strat['userId']==SingleuserId]['movieId'].tolist()
  results =pd.DataFrame()
  for movie in original:
    results = pd.concat([results,findsimilarMovie(movie)], ignore_index=True)
  results.sort_values(by = 'jaccard_sim', ascending = False, inplace = True , ignore_index=True)
  return results.iloc[0:10]

"""## Merging the models"""

def HybridRecommenderSystem(userID):
  jaccResults = findJaccardRecommendations(userID)['movieId'].tolist()
  ids, ALS_scores = ALSrecommendations([userID])
  # weighted selection
  print(jaccResults)
  Results = []
  for i in range(0,5):
    Results.append(jaccResults[i])
    Results.append(ids[0][i])
  return Results

"""# Testing

for the evaluation, a baseline is considered, the baseline is a basic standard for what we expect from the recommender system

The model is trying to be better compared to the baseline, there are 2 baselines:
- random recommender : recommend based on random selection
- popular recommender : recommend based on the most popular movies without personlization

random recommender
"""

baseline = []
for i in range(1,5):
    baseline.append(movies.sample(10)['movieId'].tolist())

"""popular recommender"""

popular = ratings.movieId.value_counts().head(10).index.tolist()
popular = [popular,popular,popular,popular]

"""what the users actully like based on the test set"""

RealUserLikes = []
for id in user_id :
    RealUserLikes.append(ratingsToMovies(test_strat[test_strat['userId']==id])['movieId'].tolist())

"""ALS model recommender"""

ALSmodel_ids,scores = ALSrecommendations(user_id)

"""Jaccard recommender"""

JaccardListForAllUsers = []
for id in user_id :
    JaccardListForAllUsers.append(findJaccardRecommendations(id)['movieId'].tolist())

"""hybird recommender"""

hybridModel = []
for id in user_id :
    hybridModel.append(HybridRecommenderSystem(id))

"""## evalution matrises

Mean average precision at k
"""

metrics.mapk(RealUserLikes,baseline)

metrics.mapk(RealUserLikes,popular)

metrics.mapk(RealUserLikes,ALSrecommendations)

metrics.mapk(RealUserLikes,JaccardListForAllUsers)

metrics.mapk(RealUserLikes,hybridModel)

"""Mean average recall at k"""

random_mark = []
for K in np.arange(1, 11):
    random_mark.extend([recmetrics.mark(RealUserLikes,baseline, k=K)])
random_mark

pop_mark = []
for K in np.arange(1, 11):
    pop_mark.extend([recmetrics.mark(RealUserLikes, popular, k=K)])
pop_mark

model_mark = []
for K in np.arange(1, 11):
    model_mark.extend([recmetrics.mark(RealUserLikes, ALSmodel_ids, k=K)])
model_mark

Jac_mark = []
for K in np.arange(1, 11):
    Jac_mark.extend([recmetrics.mark(RealUserLikes, JaccardListForAllUsers, k=K)])
Jac_mark